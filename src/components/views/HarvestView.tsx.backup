import { useState, useEffect } from "react";
import { useAppStore } from "../../stores/appStore";
import { Button } from "../ui/Button";
import { invoke } from "@tauri-apps/api/core";
import { format, addDays, startOfWeek, endOfWeek, parseISO } from "date-fns";
import type { HarvestTimeEntryResponse, TimeEntry } from "../../types";
import { Check, X, Calendar, Clock, Loader2, Edit2, Save, RefreshCw, Wheat } from "lucide-react";
import { PageWrapper } from "../layout/PageWrapper";

interface DayWithHours {
  date: string;
  hasExistingEntries: boolean;
  totalHours: number;
  selected: boolean;
}

interface PreviewEntry extends TimeEntry {
  isEditing: boolean;
  displayNotes: string;
}

export function HarvestView() {
  const [accessToken, setAccessToken] = useState("");
  const [accountId, setAccountId] = useState("");
  const [isConnecting, setIsConnecting] = useState(false);

  const harvestConfig = useAppStore((state) => state.harvestConfig);
  const setHarvestConfig = useAppStore((state) => state.setHarvestConfig);
  const setHarvestUser = useAppStore((state) => state.setHarvestUser);
  const harvestUser = useAppStore((state) => state.harvestUser);
  const setError = useAppStore((state) => state.setError);
  const workSchedule = useAppStore((state) => state.workSchedule);
  const workDays = useAppStore((state) => state.workDays);
  const projects = useAppStore((state) => state.projects);
  const tasks = useAppStore((state) => state.tasks);
  const fetchHarvestData = useAppStore((state) => state.fetchHarvestData);

  const [showSync, setShowSync] = useState(false);
  const [isFetchingData, setIsFetchingData] = useState(false);
  const [isSyncing, setIsSyncing] = useState(false);

  const [startDate, setStartDate] = useState(format(startOfWeek(new Date(), { weekStartsOn: 1 }), "yyyy-MM-dd"));
  const [endDate, setEndDate] = useState(format(endOfWeek(new Date(), { weekStartsOn: 1 }), "yyyy-MM-dd"));

  const [daysWithHours, setDaysWithHours] = useState<DayWithHours[]>([]);
  const [previewEntries, setPreviewEntries] = useState<PreviewEntry[]>([]);
  const [showPreview, setShowPreview] = useState(false);

  // These must be BEFORE any conditional returns (Rules of Hooks)
  const [defaultProjectId, setDefaultProjectId] = useState("0");
  const [defaultTaskId, setDefaultTaskId] = useState("0");

  // Update default values when harvestConfig changes
  useEffect(() => {
    if (harvestConfig) {
      setDefaultProjectId((harvestConfig.defaultProjectId || 0).toString());
      setDefaultTaskId((harvestConfig.defaultTaskId || 0).toString());
    } else {
      setDefaultProjectId("0");
      setDefaultTaskId("0");
    }
  }, [harvestConfig]);

  const handleConnect = async () => {
    if (!accessToken.trim() || !accountId.trim()) {
      setError("Please enter your Personal Access Token and Account ID");
      return;
    }

    try {
      setIsConnecting(true);

      const userResponse = await fetch("https://api.harvestapp.com/v2/users/me", {
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Harvest-Account-Id": accountId,
          "User-Agent": "Profico Farmer",
        },
      });

      if (!userResponse.ok) {
        if (userResponse.status === 403) {
          throw new Error("403 Forbidden: Your Personal Access Token may not have the required scopes. Please ensure you've granted permission to access your account information.");
        }
        throw new Error(`Failed to connect to Harvest (${userResponse.status}). Please check your credentials.`);
      }

      const user = await userResponse.json();

      setHarvestUser({
        id: user.id,
        firstName: user.first_name,
        lastName: user.last_name,
        email: user.email,
      });

      setHarvestConfig({
        accessToken,
        accountId,
        refreshToken: undefined,
        defaultProjectId: 0,
        defaultTaskId: 0,
        meetingProjectId: undefined,
        meetingTaskId: undefined,
      });

      // Trigger fetch of projects/tasks after connecting
      fetchHarvestData();
    } catch (e) {
      setError(String(e));
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = () => {
    setHarvestConfig(null);
    setHarvestUser(null);
    setAccessToken("");
    setAccountId("");
    setShowSync(false);
    setDaysWithHours([]);
    setPreviewEntries([]);
    setShowPreview(false);
  };

  const fetchTimeEntries = async () => {
    if (!harvestConfig) return;

    setIsFetchingData(true);
    try {
      const fetchedEntries = await invoke<HarvestTimeEntryResponse[]>("harvest_get_time_entries", {
        accessToken: harvestConfig.accessToken,
        accountId: harvestConfig.accountId,
        from: startDate,
        to: endDate,
        userId: null,
      });

      const daysMap = new Map<string, DayWithHours>();
      let currentDate = parseISO(startDate);
      const end = parseISO(endDate);

      while (currentDate <= end) {
        const dateStr = format(currentDate, "yyyy-MM-dd");
        daysMap.set(dateStr, {
          date: dateStr,
          hasExistingEntries: false,
          totalHours: 0,
          selected: false,
        });
        currentDate = addDays(currentDate, 1);
      }

      fetchedEntries.forEach((entry) => {
        const dateStr = entry.spentDate;
        if (daysMap.has(dateStr)) {
          const day = daysMap.get(dateStr)!;
          day.hasExistingEntries = true;
          day.totalHours += entry.hours;
        }
      });

      const daysArray = Array.from(daysMap.values()).sort((a, b) => a.date.localeCompare(b.date));
      setDaysWithHours(daysArray);
    } catch (e) {
      const errorStr = String(e);
      if (errorStr.includes("403")) {
        setError("403 Forbidden: Your Harvest account needs Administrator or Manager permissions to access time entries.");
      } else {
        setError(errorStr);
      }
    } finally {
      setIsFetchingData(false);
    }
  };

  const handleRefreshData = async () => {
    setIsFetchingData(true);
    try {
      await fetchHarvestData();
      if (showSync) {
        await fetchTimeEntries();
      }
    } catch (e) {
      setError(String(e));
    } finally {
      setIsFetchingData(false);
    }
  };

  const toggleDaySelection = (date: string) => {
    setDaysWithHours((prev) =>
      prev.map((day) =>
        day.date === date ? { ...day, selected: !day.selected } : day
      )
    );
  };

  const generatePreviewEntries = () => {
    if (!harvestConfig) return;

    const selectedDays = daysWithHours.filter((d) => d.selected);
    const newEntries: PreviewEntry[] = [];

    selectedDays.forEach((day) => {
      const workDay = workDays.find((wd) => format(new Date(wd.date), "yyyy-MM-dd") === day.date);

      const notes = workDay && workDay.commits.length > 0
        ? `Work on ${workDay.commits.length} commit(s):\n${workDay.commits.slice(0, 3).map(c => `- ${c.message}`).join("\n")}${workDay.commits.length > 3 ? "\n- ..." : ""}`
        : "Development work";

      newEntries.push({
        projectId: harvestConfig.defaultProjectId || 0,
        taskId: harvestConfig.defaultTaskId || 0,
        spentDate: new Date(day.date),
        hours: workSchedule.targetHoursPerDay,
        notes,
        externalReference: undefined,
        isEditing: false,
        displayNotes: notes,
      });
    });

    setPreviewEntries(newEntries);
    setShowPreview(true);
  };

  const updatePreviewEntry = (index: number, updates: Partial<PreviewEntry>) => {
    setPreviewEntries((prev) =>
      prev.map((entry, i) =>
        i === index ? { ...entry, ...updates } : entry
      )
    );
  };

  const handleSync = async () => {
    if (!harvestConfig) return;

    setIsSyncing(true);
    try {
      for (const entry of previewEntries) {
        await invoke("harvest_create_time_entry", {
          accessToken: harvestConfig.accessToken,
          accountId: harvestConfig.accountId,
          entry: {
            projectId: entry.projectId,
            taskId: entry.taskId,
            spentDate: format(entry.spentDate, "yyyy-MM-dd"),
            hours: entry.hours,
            notes: entry.notes,
            externalReference: entry.externalReference,
          },
        });
      }

      await fetchTimeEntries();
      setShowPreview(false);
      setDaysWithHours((prev) => prev.map((d) => ({ ...d, selected: false })));
    } catch (e) {
      setError(String(e));
    } finally {
      setIsSyncing(false);
    }
  };

  // Sync view
  if (showSync) {
    return (
      <PageWrapper view="harvest">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold text-fg-primary">Sync Time Entries</h2>
            <p className="text-sm text-fg-secondary">Select days to sync and preview before creating entries</p>
          </div>
          <div className="flex gap-2">
            <Button variant="secondary" onClick={handleRefreshData} disabled={isFetchingData}>
              {isFetchingData ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Refreshing...
                </>
              ) : (
                <>
                  <RefreshCw className="w-4 h-4 mr-2" />
                  Refresh Data
                </>
              )}
            </Button>
            <Button variant="secondary" onClick={() => setShowSync(false)}>
              <X className="w-4 h-4 mr-2" />
              Cancel
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-fg-primary mb-2">Start Date</label>
            <input
              type="date"
              value={startDate}
              onChange={(e) => setStartDate(e.target.value)}
              className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary focus:outline-none focus:ring-2 focus:ring-accent"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-fg-primary mb-2">End Date</label>
            <input
              type="date"
              value={endDate}
              onChange={(e) => setEndDate(e.target.value)}
              className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary focus:outline-none focus:ring-2 focus:ring-accent"
            />
          </div>
        </div>

        <div className="flex gap-2">
          <Button onClick={fetchTimeEntries} disabled={isFetchingData || !startDate || !endDate}>
            {isFetchingData ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Fetching...
              </>
            ) : (
              <>
                <Calendar className="w-4 h-4 mr-2" />
                Load Days
              </>
            )}
          </Button>

          {daysWithHours.length > 0 && (
            <>
              <Button
                variant="secondary"
                onClick={() => setDaysWithHours(prev => prev.map(d => ({ ...d, selected: !d.selected })))}
              >
                {daysWithHours.every(d => d.selected) ? "Deselect All" : "Select All"}
              </Button>
              <Button
                variant="secondary"
                onClick={() => setDaysWithHours(prev => prev.map(d => d.hasExistingEntries ? d : { ...d, selected: !d.selected })))}
              >
                Toggle Empty Days
              </Button>
            </>
          )}
        </div>

        {daysWithHours.length > 0 && (
          <div className="rounded-lg border border-border bg-bg-secondary overflow-hidden">
            <div className="p-4 border-b border-border bg-bg-tertiary">
              <h3 className="text-sm font-medium text-fg-primary">Select Days to Sync</h3>
              <p className="text-xs text-fg-secondary mt-1">
                Showing {daysWithHours.length} days from {startDate} to {endDate}
              </p>
            </div>
            <div className="divide-y divide-border max-h-96 overflow-y-auto">
              {daysWithHours.map((day) => (
                <div
                  key={day.date}
                  className={`p-4 flex items-center justify-between hover:bg-bg-tertiary cursor-pointer transition-colors ${
                    day.selected ? "bg-accent/5" : ""
                  }`}
                  onClick={() => toggleDaySelection(day.date)}
                >
                  <div className="flex items-center gap-4">
                    <div className={`w-5 h-5 rounded border flex items-center justify-center ${
                      day.selected ? "bg-accent border-accent" : "border-border"
                    }`}>
                      {day.selected && <Check className="w-3 h-3 text-white" />}
                    </div>
                    <div>
                      <div className="text-sm font-medium text-fg-primary">
                        {format(parseISO(day.date), "EEE, MMM d, yyyy")}
                      </div>
                      <div className="text-xs text-fg-secondary flex items-center gap-2">
                        {day.hasExistingEntries ? (
                          <>
                            <Clock className="w-3 h-3" />
                            {day.totalHours.toFixed(1)}h logged
                          </>
                        ) : (
                          <span className="text-fg-muted">No entries</span>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
            <div className="p-4 border-t border-border bg-bg-tertiary flex justify-between items-center">
              <span className="text-sm text-fg-secondary">
                {daysWithHours.filter(d => d.selected).length} days selected
              </span>
              <Button onClick={generatePreviewEntries} disabled={daysWithHours.filter(d => d.selected).length === 0}>
                Preview Entries
              </Button>
            </div>
          </div>
        )}

        {showPreview && (
          <div className="rounded-lg border border-border bg-bg-secondary overflow-hidden">
            <div className="p-4 border-b border-border bg-bg-tertiary">
              <h3 className="text-sm font-medium text-fg-primary">Preview Time Entries</h3>
              <p className="text-xs text-fg-secondary mt-1">
                Review and edit before syncing to Harvest
              </p>
            </div>
            <div className="divide-y divide-border max-h-96 overflow-y-auto">
              {previewEntries.map((entry, index) => (
                <div key={index} className="p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-fg-primary">
                      {format(entry.spentDate, "EEE, MMM d, yyyy")}
                    </span>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => updatePreviewEntry(index, { isEditing: !entry.isEditing })}
                    >
                      {entry.isEditing ? <Save className="w-4 h-4" /> : <Edit2 className="w-4 h-4" />}
                    </Button>
                  </div>

                  <div className="grid grid-cols-2 gap-3">
                    <div>
                      <label className="block text-xs text-fg-secondary mb-1">Project</label>
                      <select
                        value={entry.projectId}
                        onChange={(e) => updatePreviewEntry(index, { projectId: parseInt(e.target.value) })}
                        disabled={!entry.isEditing}
                        className="w-full px-2 py-1.5 rounded text-sm border border-border bg-bg-tertiary text-fg-primary disabled:opacity-50"
                      >
                        <option value={0}>Select project...</option>
                        {projects.map((p) => (
                          <option key={p.id} value={p.id}>
                            {p.name}
                          </option>
                        ))}
                      </select>
                    </div>
                    <div>
                      <label className="block text-xs text-fg-secondary mb-1">Task</label>
                      <select
                        value={entry.taskId}
                        onChange={(e) => updatePreviewEntry(index, { taskId: parseInt(e.target.value) })}
                        disabled={!entry.isEditing}
                        className="w-full px-2 py-1.5 rounded text-sm border border-border bg-bg-tertiary text-fg-primary disabled:opacity-50"
                      >
                        <option value={0}>Select task...</option>
                        {tasks.map((t) => (
                          <option key={t.id} value={t.id}>
                            {t.name}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>

                  <div>
                    <label className="block text-xs text-fg-secondary mb-1">Hours</label>
                    <input
                      type="number"
                      step="0.25"
                      min="0"
                      max="24"
                      value={entry.hours}
                      onChange={(e) => updatePreviewEntry(index, { hours: parseFloat(e.target.value) || 0 })}
                      disabled={!entry.isEditing}
                      className="w-full px-2 py-1.5 rounded text-sm border border-border bg-bg-tertiary text-fg-primary disabled:opacity-50"
                    />
                  </div>

                  <div>
                    <label className="block text-xs text-fg-secondary mb-1">Notes</label>
                    <textarea
                      value={entry.notes}
                      onChange={(e) => updatePreviewEntry(index, { notes: e.target.value })}
                      disabled={!entry.isEditing}
                      rows={3}
                      className="w-full px-2 py-1.5 rounded text-sm border border-border bg-bg-tertiary text-fg-primary disabled:opacity-50 resize-none"
                    />
                  </div>
                </div>
              ))}
            </div>
            <div className="p-4 border-t border-border bg-bg-tertiary flex justify-between items-center">
              <span className="text-sm text-fg-secondary">
                {previewEntries.length} entries • {previewEntries.reduce((sum, e) => sum + e.hours, 0).toFixed(1)}h total
              </span>
              <div className="flex gap-2">
                <Button variant="secondary" onClick={() => setShowPreview(false)}>
                  Back
                </Button>
                <Button
                  onClick={handleSync}
                  disabled={isSyncing || previewEntries.some(e => e.projectId === 0 || e.taskId === 0)}
                  className="text-black"
                >
                  {isSyncing ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Syncing...
                    </>
                  ) : (
                    <>
                      <Check className="w-4 h-4 mr-2" />
                      Sync to Harvest
                    </>
                  )}
                </Button>
              </div>
            </div>
          </div>
        )}
      </PageWrapper>
    );
  }

  // Connected view (not in sync mode)
  if (harvestConfig) {
    const handleSaveDefaults = () => {
      setHarvestConfig({
        ...harvestConfig,
        defaultProjectId: parseInt(defaultProjectId) || 0,
        defaultTaskId: parseInt(defaultTaskId) || 0,
      });
      setError("Default Project ID and Task ID saved!");
      setTimeout(() => setError(null), 3000);
    };

    return (
      <PageWrapper view="harvest">
        <div className="space-y-4">
          <div className="rounded-lg border border-border bg-bg-secondary p-6 space-y-4">
            <div className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-success" />
              <span className="text-sm font-medium text-fg-primary">
                Connected to Harvest
              </span>
            </div>

            <div className="space-y-2 text-sm text-fg-secondary">
              <p>Account ID: <span className="font-mono text-fg-primary">{harvestConfig.accountId}</span></p>
            </div>

            <div className="flex gap-2">
              <Button onClick={() => setShowSync(true)} className="text-black">
                <Calendar className="w-4 h-4 mr-2" />
                Sync Time Entries
              </Button>
              <Button
                variant="danger"
                onClick={handleDisconnect}
                className="text-black pr-3"
              >
                Disconnect
              </Button>
            </div>
          </div>

          {harvestUser && (
            <div className="rounded-lg border border-border bg-bg-secondary p-6">
              <h3 className="text-sm font-medium text-fg-primary mb-3">
                Connected as {harvestUser.firstName} {harvestUser.lastName}
              </h3>
              <div className="space-y-1 text-sm text-fg-secondary">
                <p>Email: <span className="text-fg-primary">{harvestUser.email}</span></p>
                <p>Account ID: <span className="font-mono text-fg-primary">{harvestConfig.accountId}</span></p>
              </div>
            </div>
          )}

          <div className="rounded-lg border border-border bg-bg-secondary p-6">
            <h3 className="text-sm font-medium text-fg-primary mb-4">
              Configuration
            </h3>

            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-fg-primary mb-2">
                  Default Project ID
                </label>
                <input
                  type="number"
                  value={defaultProjectId}
                  onChange={(e) => setDefaultProjectId(e.target.value)}
                  placeholder="e.g., 12345678"
                  className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary focus:outline-none focus:ring-2 focus:ring-accent"
                />
                <p className="text-xs text-fg-muted mt-1">
                  Find it in Harvest: Projects → Click a project → Check the URL (e.g., /projects/12345678)
                </p>
              </div>

              <div>
                <label className="block text-sm font-medium text-fg-primary mb-2">
                  Default Task ID
                </label>
                <input
                  type="number"
                  value={defaultTaskId}
                  onChange={(e) => setDefaultTaskId(e.target.value)}
                  placeholder="e.g., 87654321"
                  className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary focus:outline-none focus:ring-2 focus:ring-accent"
                />
                <p className="text-xs text-fg-muted mt-1">
                  Find it in Harvest: Project → Tasks tab → Click a task → Check the URL (e.g., /tasks/87654321)
                </p>
              </div>

              <Button onClick={handleSaveDefaults}>
                Save Defaults
              </Button>
            </div>
          </div>
        </div>
      </PageWrapper>
    );
  }

  // Not connected view
  return (
    <PageWrapper view="harvest">
      <div className="space-y-4">
        <div className="rounded-lg border border-border bg-bg-secondary p-6 space-y-4">
          <div className="flex items-start gap-4">
            <div className="w-10 h-10 rounded-lg bg-warning/10 flex items-center justify-center flex-shrink-0">
              <Wheat className="w-5 h-5 text-warning" />
            </div>
            <div className="flex-1">
              <h3 className="text-sm font-medium text-fg-primary mb-1">
                Connect to Harvest
              </h3>
              <p className="text-xs text-fg-secondary leading-relaxed">
                Connect your Harvest account using a Personal Access Token to sync time entries.
              </p>
            </div>
          </div>
        </div>

        <div className="rounded-lg border border-border bg-bg-secondary p-6 space-y-6">
          <div className="space-y-4">
            <h3 className="text-sm font-medium text-fg-primary">
              How to get your Personal Access Token:
            </h3>

            <ol className="list-decimal list-inside space-y-3 text-sm text-fg-secondary">
              <li className="pl-2">
                Go to <span className="font-mono text-xs bg-bg-tertiary px-2 py-1 rounded">Harvest ID → Developers</span>
              </li>
              <li className="pl-2">
                Create a new Personal Access Token
              </li>
              <li className="pl-2">
                <strong className="text-fg-primary">Important:</strong> When creating the token, make sure to grant access to:
                <ul className="list-disc list-inside ml-4 mt-1 space-y-1">
                  <li>Projects (Read)</li>
                  <li>Tasks (Read)</li>
                  <li>Time Entries (Read & Write)</li>
                </ul>
              </li>
              <li className="pl-2">
                Copy your Account ID from the list of accounts
              </li>
              <li className="pl-2">
                Paste both values below
              </li>
            </ol>

            <div className="mt-4 p-3 rounded bg-bg-tertiary border border-border">
              <p className="text-xs text-fg-secondary">
                <strong>Why 403 errors happen:</strong> Personal Access Tokens need explicit scopes/grants. Even if you can see projects in the Harvest UI, your PAT won't be able to access them unless you granted permission when creating the token. Recreate your PAT and check all the boxes.
              </p>
            </div>
          </div>

          <div className="h-px bg-border" />

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-fg-primary mb-2">
                Personal Access Token
              </label>
              <input
                type="password"
                value={accessToken}
                onChange={(e) => setAccessToken(e.target.value)}
                placeholder="Bearer token from Harvest ID"
                className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary placeholder:text-fg-muted focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-fg-primary mb-2">
                Account ID
              </label>
              <input
                type="text"
                value={accountId}
                onChange={(e) => setAccountId(e.target.value)}
                placeholder="Your Harvest Account ID (numbers only)"
                className="w-full px-3 py-2 rounded-md border border-border bg-bg-tertiary text-sm text-fg-primary placeholder:text-fg-muted focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent"
              />
            </div>

            <Button
              onClick={handleConnect}
              disabled={isConnecting || !accessToken.trim() || !accountId.trim()}
              className="w-full"
            >
              {isConnecting ? "Connecting..." : "Connect Harvest"}
            </Button>
          </div>
        </div>
      </PageWrapper>
    );
  }
}
